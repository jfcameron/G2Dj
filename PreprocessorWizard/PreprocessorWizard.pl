#!/usr/bin/perl -w
# For instructions run this script with the arg --help
# DO NOT EDIT: Copyright Richard T. Bailey 2015.
# DO NOT EDIT: This software is provided to the initial recipient only for use as follows:
# DO NOT EDIT: 1.  The initial recipient may use the software for any project on any computer in any location.
# DO NOT EDIT: 2.  People who work on a project of the initial recipient may use it on that project only.
# DO NOT EDIT: Others who need their own copy must get it from www.rtbaileyphd.com
# DO NOT EDIT: Original or subsequent recipients may modify the code except for the DO NOT EDIT lines.
# DO NOT EDIT: THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# DO NOT EDIT: WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# DO NOT EDIT: MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# DO NOT EDIT: ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# DO NOT EDIT: WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# DO NOT EDIT: ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# DO NOT EDIT: OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
# DO NOT EDIT: The original skeleton of this script was generated by www.rtbaileyphd.com/perlwizard Jan 14, 2015 10:10:50 PM
# DO NOT EDIT: The PerlWizard generator was facilitated by the FreeMarker template engine (www.freemarker.org) by
# DO NOT EDIT: the Visigoth Software Society (http://www.visigoths.org/) (link broken).
# PerlWizardTemplate version used: PerlWizardTemplate.pl was last modified Fri Oct 03 14:49:27 2014
# PerlWizard         version used: PerlWizard.jar was built Tue Dec 30 17:27:37 2014
# #FILE_LAST_MODIFIED#
use strict;
use diagnostics; # This provides expanded error messages.
if (!@INC) {@INC = ()};
push ( ## TBD: Revise list of locations for imported files if needed.
    @INC,
    qw()
);
## Section: Variables for command-line options:
use vars qw(
    $ask_all
    $ask_all_default
    $defaults_file
    $defaults_file_default
    $Commentizer1
    $Commentizer1_default
    $Files
    $Files_default
    $Extns
    $Extns_default
    $BackupDir
    $BackupDir_default
    $StartDir
    $StartDir_default
    $SkipDirPtns
    $SkipDirPtns_default
    $DoFile
    $DoFile_default
    $MaxDepth
    $MaxDepth_default
    $List
    $List_default
    $PlaceholderI4
    $PlaceholderI4_default
    $Commentizer2
    $Commentizer2_default
    $DoDirPtns
    $DoDirPtns_default
    $PlaceholderB1
    $PlaceholderB1_default
    $PlaceholderB2
    $PlaceholderB2_default
    $PlaceholderB3
    $PlaceholderB3_default
    $KeepResult
    $KeepResult_default
    $Decommentize
    $Decommentize_default
    $PlaceholderB4
    $PlaceholderB4_default
    $log_file
    $log_file_default
    $help
    $version
    $batch
    $batch_default
    $debug
);
## Placeholder variables (if any) are provided for later enhancement of this script.
## The Placeholders are needed since PerlWizard cannot add more variables once the script is generated.
## To use a Placeholder, globally replace the name of one by a conventional name and then edit the code as needed.
## However, doing that manually will mess up the nice formatting.
## Instead of doing this manually, try the RenameVar.pl script at www.rtbaileyphd.com/download
## RenameVar.pl will do the global replacement in such a way that the column formatting is maintained.
## Section: Other needed variables
use vars qw(
    $pgm
    $user
    $home
    $now
    $pgm_version
    $cwd
    $stdin
    $temp
    $option
    @options
    $options_valid
    %strs
    $null_str
    %is_storeds
    %regexps
    %regexp_hints
    %prompt_fors
    %switch_defaults_files
    %get_input_refs
    %option_types
    $this_host
    $is_dos
    $path_slash
    $new_defaults_file
    $cmd
    @ARGV_Orig
);
@ARGV_Orig = @ARGV; # Keep original @ARGV because GetOpt::Long will change it.  See also sub StartOver() in gnrl_utils.pl
## Section: Options ordering
## The order of options in the following array defines the order
## of presentation to the user in the interactive mode and also
## the order in which computable default values are computed.
## TBD: to change the order, merely reorder @options.  Do not move other chunks of code around.
## But leave ask_all and defaults_file at the head and log_file at the tail of @options.
@options = qw (
    ask_all
    defaults_file
    List
    Extns
    Commentizer1
    Commentizer2
    Decommentize
    KeepResult
    StartDir
    DoDirPtns
    SkipDirPtns
    MaxDepth
    BackupDir
    DoFile
    Files
    PlaceholderB1
    PlaceholderB2
    PlaceholderB3
    PlaceholderB4
    PlaceholderI4
    log_file
);
require 'file_mgr.pl'      ; # Utilities related to file operations, including log_file operations.  This is worth perusing.
require 'gnrl_utils.pl'    ; # Other utilities, such as get_stdin().  This is worth perusing.
require 'PerlWizardSubs.pl'; # Utilities directly related to PerlWizard scripts
## Section: Option Attributes
## =========================================================================================
## =========================================================================================
##
## %option_types defines how the options are presented to Getopt::Long.  If you want to change
## the type this is the only place where you should need to change it.
##
## %prompt_fors governs which unentered options are prompted for when !$ask_all and !$batch
## Use 1 for options you generally need to specify.  Use 0 for obscure options.
## If $ask_all is true, the user is asked to supply all options except for Placeholders.
## If $batch is true, there is no prompting and the defaults are used in all cases including
## any get_stdin() calls that you add.
##
## %regexps contains the regular expressions that the option values must match.  Examples:
##      $regexps{ChangeFreq       } = "/^(always|hourly|daily|weekly|monthly|yearly)\$/i" ;  # creates a menu
##      $regexps{ChangeFreq       } = MkMenu(qw(always hourly daily weekly monthly yearly)); # easier way to create a menu
##      $regexps{NewHostDrive     } = '/^[A-Z]?$/i' ; # Windows drive letter, valid or not
##      $regexps{NewHostDrive     } = MkMenu(WriteableSystemDrives()) ; # Writable Windows drive letter.  See file_mgr.pl
##      $regexps{FilePerms        } = "/^(|0[0-7]{3,4})\$/i" ; # octal number is needed
##
## %regexp_hints contains English explanations of the %regexps expressions.  Examples:
##      $regexp_hints{NewHostDrive    } = "Enter a Windows drive letter (or '')" ;
##      $regexp_hints{FilePerms       } = "Enter blank ('') or else an octal number like 0555" ;
##
## %is_storeds governs which options are stored in the users' defaults files.
## Options that are not stored have defaults that necessarily always get recomputed at run-time.
## Do not store defaults if they depend on the date or the state of an external system,
## and there is a way to compute a reasonable default.
## Do not store a default if you need the user to explicitly enter a fresh value every run.
##
## %switch_defaults_files governs defaults_file switching after each option is read.
## If, for example, the option is 'Customer' and $Customer eq "John Jones" and the old defaults file
## was, "pwiz/MyScript.pl.someuser.defaults", then the new defaults file for the next option will be
## "pwiz/MyScript.pl.someuser.John_Jones.defaults"
## $switch_defaults_files{MyOption} should be 1 if MyOption represents a major category, the switching
## of which would generally mean a significant change to the usual values of subsequent options.
## If you learn how to use %switch_defaults you can make your programs far more user-friendly
## than the typical command-line program.
##
## %get_input_refs allows special input handlers to be defined in case non-standard input handling
## is needed for certain options.  Most likely you will not need this feature, but
## see sub get_option_val() in PerlWizardSubs.pl for more details and sub get_ask_all_modifier() for an example.
## If you need more specialized handling for option ABC, you can usually accomplish it by modifying
## sub get_ABC_default().
$option_types         {ask_all                         } = "bool" ;
$prompt_fors          {ask_all                         } = 0 ; # 0 for obscure options, 1 for common options
$regexps              {ask_all                         } = "bool" ;
$regexp_hints         {ask_all                         } = "" ;
$is_storeds           {ask_all                         } = 1 ; # 0 for defaults that should always be recomputed.
$switch_defaults_files{ask_all                         } = 0 ; # 1 means switch to new defaults_file after option is processed
$get_input_refs       {ask_all                         } = 0 ;
$option_types         {defaults_file                   } = "string" ;
$prompt_fors          {defaults_file                   } = 0 ; # 0 for obscure options, 1 for common options
$regexps              {defaults_file                   } = "" ;
$regexp_hints         {defaults_file                   } = "" ;
$is_storeds           {defaults_file                   } = 1 ; # 0 for defaults that should always be recomputed.
$switch_defaults_files{defaults_file                   } = 0 ; # 1 means switch to new defaults_file after option is processed
$get_input_refs       {defaults_file                   } = 0 ;
$option_types         {Commentizer1                    } = "string" ;
$prompt_fors          {Commentizer1                    } = 0 ; # 0 for obscure options, 1 for common options
$regexps              {Commentizer1                    } = "" ;
$regexp_hints         {Commentizer1                    } = "" ;
$is_storeds           {Commentizer1                    } = 1 ; # 0 for defaults that should always be recomputed.
$switch_defaults_files{Commentizer1                    } = 0 ; # 1 means switch to new defaults_file after option is processed
$get_input_refs       {Commentizer1                    } = 0 ;
$option_types         {Commentizer2                    } = "string" ;
$prompt_fors          {Commentizer2                    } = 0 ; # 0 for obscure options, 1 for common options
$regexps              {Commentizer2                    } = "" ;
$regexp_hints         {Commentizer2                    } = "" ;
$is_storeds           {Commentizer2                    } = 1 ; # 0 for defaults that should always be recomputed.
$switch_defaults_files{Commentizer2                    } = 0 ; # 1 means switch to new defaults_file after option is processed
$get_input_refs       {Commentizer2                    } = 0 ;
$option_types         {Decommentize                    } = "bool" ;
$prompt_fors          {Decommentize                    } = 0 ; # 0 for obscure options, 1 for common options
$regexps              {Decommentize                    } = "bool" ;
$regexp_hints         {Decommentize                    } = "" ;
$is_storeds           {Decommentize                    } = 1 ; # 0 for defaults that should always be recomputed.
$switch_defaults_files{Decommentize                    } = 0 ; # 1 means switch to new defaults_file after option is processed
$get_input_refs       {Decommentize                    } = 0 ;
$option_types         {PlaceholderB3                   } = "bool" ;
$prompt_fors          {PlaceholderB3                   } = 1 ; # 0 for obscure options, 1 for common options
$regexps              {PlaceholderB3                   } = "bool" ;
$regexp_hints         {PlaceholderB3                   } = "" ;
$is_storeds           {PlaceholderB3                   } = 1 ; # 0 for defaults that should always be recomputed.
$switch_defaults_files{PlaceholderB3                   } = 0 ; # 1 means switch to new defaults_file after option is processed
$get_input_refs       {PlaceholderB3                   } = 0 ;
$option_types         {Files                           } = "argv string" ;
$prompt_fors          {Files                           } = 1 ; # 0 for obscure options, 1 for common options
$regexps              {Files                           } = "" ;
$regexp_hints         {Files                           } = "" ;
$is_storeds           {Files                           } = 1 ; # 0 for defaults that should always be recomputed.
$switch_defaults_files{Files                           } = 0 ; # 1 means switch to new defaults_file after option is processed
$get_input_refs       {Files                           } = 0 ;
$option_types         {Extns                           } = "string" ;
$prompt_fors          {Extns                           } = 1 ; # 0 for obscure options, 1 for common options
$regexps              {Extns                           } = "";
$regexp_hints         {Extns                           } = "" ;
$is_storeds           {Extns                           } = 1 ; # 0 for defaults that should always be recomputed.
$switch_defaults_files{Extns                           } = 1 ; # 1 means switch to new defaults_file after option is processed
$get_input_refs       {Extns                           } = 0 ;
$option_types         {BackupDir                       } = "string" ;
$prompt_fors          {BackupDir                       } = 1 ; # 0 for obscure options, 1 for common options
$regexps              {BackupDir                       } = "" ;
$regexp_hints         {BackupDir                       } = "" ;
$is_storeds           {BackupDir                       } = 1 ; # 0 for defaults that should always be recomputed.
$switch_defaults_files{BackupDir                       } = 0 ; # 1 means switch to new defaults_file after option is processed
$get_input_refs       {BackupDir                       } = 0 ;
$option_types         {StartDir                        } = "string" ;
$prompt_fors          {StartDir                        } = 1 ; # 0 for obscure options, 1 for common options
$regexps              {StartDir                        } = "edir?" ;
$regexp_hints         {StartDir                        } = "" ;
$is_storeds           {StartDir                        } = 1 ; # 0 for defaults that should always be recomputed.
$switch_defaults_files{StartDir                        } = 0 ; # 1 means switch to new defaults_file after option is processed
$get_input_refs       {StartDir                        } = 0 ;
$option_types         {SkipDirPtns                     } = "string" ;
$prompt_fors          {SkipDirPtns                     } = 1 ; # 0 for obscure options, 1 for common options
$regexps              {SkipDirPtns                     } = "" ;
$regexp_hints         {SkipDirPtns                     } = "" ;
$is_storeds           {SkipDirPtns                     } = 1 ; # 0 for defaults that should always be recomputed.
$switch_defaults_files{SkipDirPtns                     } = 0 ; # 1 means switch to new defaults_file after option is processed
$get_input_refs       {SkipDirPtns                     } = 0 ;
$option_types         {DoFile                          } = "string" ;
$prompt_fors          {DoFile                          } = 1 ; # 0 for obscure options, 1 for common options
$regexps              {DoFile                          } = "" ;
$regexp_hints         {DoFile                          } = "" ;
$is_storeds           {DoFile                          } = 1 ; # 0 for defaults that should always be recomputed.
$switch_defaults_files{DoFile                          } = 0 ; # 1 means switch to new defaults_file after option is processed
$get_input_refs       {DoFile                          } = 0 ;
$option_types         {MaxDepth                        } = "int" ;
$prompt_fors          {MaxDepth                        } = 1 ; # 0 for obscure options, 1 for common options
$regexps              {MaxDepth                        } = "/^[1-9][0-9]*/" ;
$regexp_hints         {MaxDepth                        } = "Enter a positive number" ;
$is_storeds           {MaxDepth                        } = 1 ; # 0 for defaults that should always be recomputed.
$switch_defaults_files{MaxDepth                        } = 0 ; # 1 means switch to new defaults_file after option is processed
$get_input_refs       {MaxDepth                        } = 0 ;
$option_types         {List                            } = "string" ;
$prompt_fors          {List                            } = 1 ; # 0 for obscure options, 1 for common options
$regexps              {List                            } = "efile?" ;
$regexp_hints         {List                            } = "" ;
$is_storeds           {List                            } = 1 ; # 0 for defaults that should always be recomputed.
$switch_defaults_files{List                            } = 0 ; # 1 means switch to new defaults_file after option is processed
$get_input_refs       {List                            } = 0 ;
$option_types         {PlaceholderI4                   } = "int" ;
$prompt_fors          {PlaceholderI4                   } = 1 ; # 0 for obscure options, 1 for common options
$regexps              {PlaceholderI4                   } = "" ;
$regexp_hints         {PlaceholderI4                   } = "" ;
$is_storeds           {PlaceholderI4                   } = 1 ; # 0 for defaults that should always be recomputed.
$switch_defaults_files{PlaceholderI4                   } = 0 ; # 1 means switch to new defaults_file after option is processed
$get_input_refs       {PlaceholderI4                   } = 0 ;
$option_types         {DoDirPtns                       } = "string" ;
$prompt_fors          {DoDirPtns                       } = 1 ; # 0 for obscure options, 1 for common options
$regexps              {DoDirPtns                       } = "" ;
$regexp_hints         {DoDirPtns                       } = "" ;
$is_storeds           {DoDirPtns                       } = 1 ; # 0 for defaults that should always be recomputed.
$switch_defaults_files{DoDirPtns                       } = 0 ; # 1 means switch to new defaults_file after option is processed
$get_input_refs       {DoDirPtns                       } = 0 ;
$option_types         {PlaceholderB1                   } = "bool" ;
$prompt_fors          {PlaceholderB1                   } = 1 ; # 0 for obscure options, 1 for common options
$regexps              {PlaceholderB1                   } = "bool" ;
$regexp_hints         {PlaceholderB1                   } = "" ;
$is_storeds           {PlaceholderB1                   } = 1 ; # 0 for defaults that should always be recomputed.
$switch_defaults_files{PlaceholderB1                   } = 0 ; # 1 means switch to new defaults_file after option is processed
$get_input_refs       {PlaceholderB1                   } = 0 ;
$option_types         {PlaceholderB2                   } = "bool" ;
$prompt_fors          {PlaceholderB2                   } = 1 ; # 0 for obscure options, 1 for common options
$regexps              {PlaceholderB2                   } = "" ;
$regexp_hints         {PlaceholderB2                   } = "bool" ;
$is_storeds           {PlaceholderB2                   } = 1 ; # 0 for defaults that should always be recomputed.
$switch_defaults_files{PlaceholderB2                   } = 0 ; # 1 means switch to new defaults_file after option is processed
$get_input_refs       {PlaceholderB2                   } = 0 ;
$option_types         {KeepResult                      } = "bool" ;
$prompt_fors          {KeepResult                      } = 0 ; # 0 for obscure options, 1 for common options
$regexps              {KeepResult                      } = "bool" ;
$regexp_hints         {KeepResult                      } = "" ;
$is_storeds           {KeepResult                      } = 0 ; # 0 for defaults that should always be recomputed.
$switch_defaults_files{KeepResult                      } = 0 ; # 1 means switch to new defaults_file after option is processed
$get_input_refs       {KeepResult                      } = 0 ;
$option_types         {PlaceholderB4                   } = "bool" ;
$prompt_fors          {PlaceholderB4                   } = 1 ; # 0 for obscure options, 1 for common options
$regexps              {PlaceholderB4                   } = "bool" ;
$regexp_hints         {PlaceholderB4                   } = "" ;
$is_storeds           {PlaceholderB4                   } = 1 ; # 0 for defaults that should always be recomputed.
$switch_defaults_files{PlaceholderB4                   } = 0 ; # 1 means switch to new defaults_file after option is processed
$get_input_refs       {PlaceholderB4                   } = 0 ;
$option_types         {log_file                        } = "string" ;
$prompt_fors          {log_file                        } = 0 ; # 0 for obscure options, 1 for common options
$regexps              {log_file                        } = "" ;
$regexp_hints         {log_file                        } = "" ;
$is_storeds           {log_file                        } = 0 ; # 0 for defaults that should always be recomputed.
$switch_defaults_files{log_file                        } = 0 ; # 1 means switch to new defaults_file after option is processed
$get_input_refs       {log_file                        } = 0 ;
## =========================================================================================
## =========================================================================================
## Section: Initialize some variables
$get_input_refs{ask_all} = \&get_ask_all_modifier; # an example of a special input handler.  See PerlWizardSubs.pl
use Cwd;
use Sys::Hostname;
$user = $ENV{NAME} || $ENV{USERNAME} || $ENV{LOGNAME} || $ENV{USER} || getlogin() || "UNKNOWNUSER";
$home = $ENV{HOME} || $ENV{USERPROFILE} || "UKNOWNHOME";
$is_dos = !defined($ENV{SHELL}); ## true if MS DOS or MS Windows
$path_slash = file_mgr::get_path_slash();
$pgm = tail($0); ## name of program
$pgm_version = '$Id: PreprocessorWizard.pl,v 1.4 2015/07/29 23:29:38 rtbailey Exp rtbailey $'; ## Source code control system version string
$cwd = cwd();
$null_str = "''"; ## string used to override a nonblank default with a null string.
$now = FormattedTime("%a %b %d %H:%M:%S %Y"); # time and date string like "Fri Mar 15 21:50:20 2013"  Google "man strftime".
$this_host = hostname;
$batch_default = $batch = 0; # This sets the default mode - interactive or batch (unless $ask_all is true)
$debug = 0;
$gnrl_utils::get_stdin_ct = 0; # For the StartOver() logic below
my %option_specs;
my %type_map = ("string" => "=s", "int" => "=i", "float" => "=f", "bool" => "!", "argv string" => 0);
foreach $option (@options) {
    $option_specs{$option} = $option . $type_map{$option_types{$option}}; # name + type spec for Getopt::Long
}
$| = 1; # turn off buffering so error messages from Getopt::Long::GetOptions() appear in the right place.
## Section: Load vars from command line & defaults files
#require 'Getopt/Long.pm'; ## handles initial processing of command-line options.  See also help section plus http://perldoc.perl.org/Getopt/Long.html
use Getopt::Long; ## handles initial processing of command-line options.  See also help section plus http://perldoc.perl.org/Getopt/Long.html
#=== READ COMMAND LINE OPTIONS  ======================================================
$options_valid = Getopt::Long::GetOptions(
    $option_specs{ask_all                         } => \$ask_all                         ,
    $option_specs{defaults_file                   } => \$defaults_file                   ,
    $option_specs{Commentizer1                    } => \$Commentizer1                    ,
    $option_specs{PlaceholderB2                   } => \$PlaceholderB2                   ,
    $option_specs{PlaceholderB3                   } => \$PlaceholderB3                   ,
    $option_specs{Files                           } => \$Files                           ,
    $option_specs{Extns                           } => \$Extns                           ,
    $option_specs{BackupDir                       } => \$BackupDir                       ,
    $option_specs{StartDir                        } => \$StartDir                        ,
    $option_specs{SkipDirPtns                     } => \$SkipDirPtns                     ,
    $option_specs{DoFile                          } => \$DoFile                          ,
    $option_specs{MaxDepth                        } => \$MaxDepth                        ,
    $option_specs{List                            } => \$List                            ,
    $option_specs{PlaceholderI4                   } => \$PlaceholderI4                   ,
    $option_specs{Commentizer2                    } => \$Commentizer2                    ,
    $option_specs{DoDirPtns                       } => \$DoDirPtns                       ,
    $option_specs{PlaceholderB1                   } => \$PlaceholderB1                   ,
    $option_specs{KeepResult                      } => \$KeepResult                      ,
    $option_specs{Decommentize                    } => \$Decommentize                    ,
    $option_specs{PlaceholderB4                   } => \$PlaceholderB4                   ,
    $option_specs{log_file                        } => \$log_file                        ,
    "help!"                                         => \$help                            ,
    "version!"                                      => \$version                         ,
    "debug!"                                        => \$debug                           ,
    "batch!"                                        => \$batch                           ,
);
#======================================================================================
$Commentizer1                    = "@ARGV" if (@ARGV && $option_types{Commentizer1                    } eq "argv string");
$PlaceholderB3                   = "@ARGV" if (@ARGV && $option_types{PlaceholderB3                   } eq "argv string");
$Files                           = "@ARGV" if (@ARGV && $option_types{Files                           } eq "argv string");
$Extns                           = "@ARGV" if (@ARGV && $option_types{Extns                           } eq "argv string");
$BackupDir                       = "@ARGV" if (@ARGV && $option_types{BackupDir                       } eq "argv string");
$StartDir                        = "@ARGV" if (@ARGV && $option_types{StartDir                        } eq "argv string");
$SkipDirPtns                     = "@ARGV" if (@ARGV && $option_types{SkipDirPtns                     } eq "argv string");
$DoFile                          = "@ARGV" if (@ARGV && $option_types{DoFile                          } eq "argv string");
$MaxDepth                        = "@ARGV" if (@ARGV && $option_types{MaxDepth                        } eq "argv string");
$List                            = "@ARGV" if (@ARGV && $option_types{List                            } eq "argv string");
$PlaceholderI4                   = "@ARGV" if (@ARGV && $option_types{PlaceholderI4                   } eq "argv string");
$Commentizer2                    = "@ARGV" if (@ARGV && $option_types{Commentizer2                    } eq "argv string");
$DoDirPtns                       = "@ARGV" if (@ARGV && $option_types{DoDirPtns                       } eq "argv string");
$PlaceholderB1                   = "@ARGV" if (@ARGV && $option_types{PlaceholderB1                   } eq "argv string");
$PlaceholderB2                   = "@ARGV" if (@ARGV && $option_types{PlaceholderB2                   } eq "argv string");
$KeepResult                      = "@ARGV" if (@ARGV && $option_types{KeepResult                      } eq "argv string");
$Decommentize                    = "@ARGV" if (@ARGV && $option_types{Decommentize                    } eq "argv string");
$PlaceholderB4                   = "@ARGV" if (@ARGV && $option_types{PlaceholderB4                   } eq "argv string");
%option_specs = (); # values no longer needed
printenv() if is_true($debug); ## see gnrl_utils.pl
my $defaults_file_initial;
if (defined($defaults_file)) {
    $defaults_file = NormalizePath($defaults_file);
    $defaults_file_initial = $defaults_file;
} else {
    get_defaults_file_default();
    $defaults_file_default = NormalizePath($defaults_file_default);
    $defaults_file_initial = $defaults_file_default;
}
#=== READ DEFAULTS FILE(S) ============================================================
load_defaults($defaults_file_initial); ## from file_mgr.  Blank file name is OK, in which case this is a no-op.
type($defaults_file_initial, "VI: old defaults: ") if $debug && $defaults_file_initial;
if ($defaults_file_default && $defaults_file_initial ne $defaults_file_default) {
    load_defaults($defaults_file_default);
    type($defaults_file_default, "VI: old defaults: ") if $debug;
}
#======================================================================================
if (is_true($ask_all)) {$batch = 0;} ## $ask_all overrides $batch
## Section: Help
$help ||= !$options_valid;
if ($help) {
    # Within this help block, the only items that a developer really needs to be concerned about
    # are the $option_descriptions{} assignments and the Purpose section.  Keep these up to date,
    # and the rest takes care of itself.
    my  $nlsub = "\n" . ' ' x 46;
    sub option_help_line {
        my ($option_name, $option_type, $option_description) = @_;
        $option_description =~ s/\n/$nlsub/g; # now multi-line descriptions will be correctly indented
        sprintf("    %-33s %-7s %s\n", $option_name, $option_type, $option_description);
    }
    %strs = (
        PromptingEnabled   => "Prompting enabled unless -batch.",
        PromptingDisabled  => "Prompting disabled unless -ask_all.",
        DefaultStored      => "Default stored in defaults_file.",
        DefaultComputed    => "Default computed each run.",
        Sticky             => "Sticky - override on command-line or -ask_all.",
        NotSticky          => "Not sticky.",
        SwitchesDefaults   => "Value switches defaults_file.",
        NoSwitching        => "No defaults_file switch.",
    );
    my %is_storeds_descriptions;
    my %prompt_fors_descriptions;
    my %sticky_descriptions;
    my %switch_descriptions;
    foreach $option (@options) {
        $prompt_fors_descriptions{$option} = $prompt_fors{$option}                            ? $strs{PromptingEnabled} : $strs{PromptingDisabled} ;
        $is_storeds_descriptions{$option}  = $is_storeds{$option}                             ? $strs{DefaultStored}    : $strs{DefaultComputed}   ;
        $sticky_descriptions{$option}      = ($is_storeds{$option} && !$prompt_fors{$option}) ? $strs{Sticky}           : $strs{NotSticky}         ;
        $switch_descriptions{$option}      = $switch_defaults_files{$option}                  ? $strs{SwitchesDefaults} : $strs{NoSwitching}       ;
    }
    # Section: Option Descriptions for help
    my  %option_descriptions; # TBD Keep these descriptions current as the code matures.
    $option_descriptions{ask_all} =
        "Enables prompting for minor options.\n" .
        "Note: running w/ -ask_all leaves the feature enabled\n" .
        "for future runs until you run with -noask_all.";
    $option_descriptions{defaults_file} =
        "Head of file array where defaults for options marked\n" .
        "\"$strs{DefaultStored}\" are stored.\n" .
        "The file array will be updated each time $pgm\n" .
        "is run interactively (-nobatch), so different defaults\n" .
        "can apply each time $pgm is run.";
    $option_descriptions{List} =
        "Name of a file that contains lines with file specs to process.\n" .
        "See rtbaileyphd.com/preprocessorwizard for an example.\n" .
        "When List is specified, then  \$StartDir, \$DoDirPtns, \n" .
        "\$SkipDirPtns, \$MaxDepth, and \$Files should not be specified.";
    $option_descriptions{Commentizer1} =
        "String used to commentize the directives.";
    $option_descriptions{Commentizer2} =
        "String used to commentize the deactivated lines.\n" .
        "This must be different from \$Commentizer1";
    $option_descriptions{PlaceholderB2} =
        "Description TBD";
    $option_descriptions{PlaceholderB3} =
        "TBD - description for help section";
    $option_descriptions{Extns} =
        "Space-separated list of programming language extensions";
    $option_descriptions{BackupDir} =
        "The directory where backups for all preprocessed files\n" .
        "are to be kept.  This is also the directory where \n" .
        "the $pgm log file will usually be put.";
    $option_descriptions{StartDir} =
        "A non-blank value causes $pgm to search\n" .
        "the \$StartDir directory tree for files that\n" .
        "have any of the \$Extns file extensions.\n" .
        "A non-blank value also causes the \$Files\n".
        "parameter to be ignored.\n" .
        "NOTE: Using this \$StartDir option is much slower than\n" .
        "using the \$Files option.";
    $option_descriptions{DoDirPtns} =
        "This applies only if \$StartDir is not blank.\n" .
        "This is a space-delimited list of directory patterns in \$StartDir\n" .
        "that should be considered.  An empty string or * means to consider all dirs.\n" .
        "The patterns matches are done using fully qualified dir names.\n" ;
    $option_descriptions{SkipDirPtns} =
        "This applies only if \$StartDir is not blank.\n" .
        "This is a space-delimited list of directory patterns in \$StartDir\n" .
        "that should be skipped.  (e.g.: tmp *.old temp)\n" .
        "The patterns matches are done using fully qualified dir names.\n" .
        "\$BackupDir is silently added to \$SkipDirPtns to\n" .
        "prevent an infinite loop.";
    $option_descriptions{MaxDepth} =
        "This applies only if \$StartDir is not blank.\n" .
        "Maximum number of directory levels to search.\n" .
        "This must be a positive number.";
    $option_descriptions{DoFile} =
        "The optional DoFile can be used to define or redefine \n" .
        "variables in $pgm just prior to\n" .
        "starting the preprocessing via the following:\n" .
        "    do \$DoFile if \$DoFile;\n" .
        "Typically, \$DoFile would contain statements to initialize \n" .
        "the \%global hash, e.g \$DoFile might contain:\n" .
        "    \$global{BuildFreewareVersion} = 1;\n" .
        "    \$global{DebugMapReader} = 1;\n" .
        "If \$Files and \$StartDir are not specified, then \$DoFile \n" .
        "could initialize \@Files.  E.g.:\n" .
        "    \@Files = glob(\"src/*/*/*.java\")";
    $option_descriptions{Files} =
        "This applies only if \$StartDir is blank.\n" .
        "List of files to preprocess.  List items may \n" .
        "contain wildcard specs and/or metaspecs.\n" .
        "A metaspec is just \@Somefilename where file \n" .
        "Somefilename itself contains\n" .
        "filenames, wildcards, metaspecs, or #-style comment lines.\n" .
        "Somefilename can have multiple lines of entries and comments.";
    $option_descriptions{PlaceholderI4} =
        "TBD - description for help section";
    $option_descriptions{PlaceholderB1} =
        "TBD - description for help section";
    $option_descriptions{KeepResult} =
        "false is for testing only.  Generally, this should be true.";
    $option_descriptions{Decommentize} =
        "true means to remove all autogenerated commentizers";
    $option_descriptions{PlaceholderB4} =
        "TBD";
    $option_descriptions{log_file} =
        "Name of the log file";
    print("\n    This is a PerlWizard script originally generated by www.rtbaileyphd.com/perlwizard Jan 14, 2015 10:10:50 PM\n\n"); # DO NOT EDIT
    # Section: Purpose
    print <<"    END_OF_SCRIPT_HELP1";
    Purpose:  $pgm is WYSIWYG preprocessor for Java, Perl, shell scripts,
    and any other language that supports left-delimited comments.
    WYSIWYG means that inactive sections of code are commentized
    (e.g., by //. for Java, #. for Perl, '. for Visual Basic).
    When $pgm runs and finds that any lines need to be changed,
    it makes those changes on the original source code so the programmer can
    actually see what lines are deactived (commentized).
    Being WYSIWIG addresses the primary complaint against the C preprocessor,
    which is that code which makes heavy use of the C preprocessor is difficult
    to read.  This is because inactive code may be difficult to spot.
    See rtbaileyphd.com/preprocessorwizard for examples.
    If Commentizer1 is, say, //., then $pgm supports the following:
        //.define SimpleVar
        //.undef  SimpleVar
        //.if     SimpleVar | SimpleExpression | PerlExpression
        //.ifndef SimpleVar | SimpleExpression | PerlExpression
        //.elsif  SimpleVar | SimpleExpression | PerlExpression
        //.else
        //.endif
        //.eval   PerlExpression
    where SimpleVar is just a word consisting of alphanumeric characters only, and
    SimpleExpression is just an expression containing SimpleVar terms.
    Helping to implement $pgm are:
    o   the three global hashes %local, %global, and %ENV
    o   an optional \$DoFile that is executed once before any files are processed.
        This \$DoFile typically would initialize the %global hash, e.g.:
        \$global{DebugAll} = 1;
    o   the use of the Perl eval statement
    //.define SimpleVar is exactly the same as //.eval \$local{SimpleVar} = 1
    //.undef  SimpleVar is exactly the same as //.eval \$local{SimpleVar} = 0
    A reference to SimpleVar in //.if returns \$local{SimpleVar} if
    \$local{SimpleVar} is defined; otherwise
    a reference to SimpleVar in //.if returns \$global{SimpleVar} if
    \$global{SimpleVar} is defined; otherwise
    a reference to SimpleVar in //.if returns \$ENV{SimpleVar} if
    \$ENV{SimpleVar} is defined; otherwise 0 is returned
    A PerlExpression can reference any global Perl variables.  These could include
    %ENV, %local, %global, and any global variables declared in the \$DoFile.
    A PerlExpression can be anything that would be allowed in a Perl eval string.
    For conveninece, $pgm supports the following aliases:
    //.define == //.show
    //.undef  == //.hide
    //.if     == //.ifdef
    //.elif   == //.elsif   == //.elseif   == //.else if
    //.endif  == //.end if
    For efficiency, $pgm can be loaded once and read in and preprocess
    all of the files in a project or directory tree.
    $pgm should be called in the pre-compile phase of your program build.
    All of the files that $pgm will process are stored in global var \@Files.
    \@Files can be populated using the WizFind.pm module (a wrapper around File::find),
    or \@Files can be populated with wild-card specs on the command line
    \@Files can also be set up in \$DoFile.
    $pgm will back up every source file before altering it.
    See \$BackupDir.
    Author:   rtbaileyphd.com
    Version:  $pgm_version
    In the descriptions below, "$strs{PromptingEnabled}" means you will be prompted to
    enter a value if you did not enter it on the command line and -batch is not specified.
    "$strs{PromptingDisabled}" means if you did not enter it on the command
    line  you will not be prompted for the value unless -ask_all is on the command line.
    "$strs{DefaultStored}" means what you enter on this run
    will be used as a default on the next run.
    "$strs{Sticky}" means the default value will persist over
    subsequent runs unless you explicitly override the default by entering it on the
    command line or enter -ask_all on the command line and then reset it when prompted.
    "$strs{SwitchesDefaults}" means processing of the option will
    cause the defaults_file to be switched after the option is processed.
    The new defaults_file name is derived from the previous one plus the value of the option.
    This is used when a change to a major option value means reasonable defaults
    for all subsequent options undoubtedly change with it.
    This feature (common to all PerlWizard scripts) means this script
    if far more likely to divine the correct defaults for users.
    See the log file for specific default files used for any particular run.
    END_OF_SCRIPT_HELP1
    ###################
    print option_help_line('OPTION', 'TYPE', 'DESCRIPTION');
    print option_help_line('------', '----', '-----------');
    foreach $option (@options) {
        next if $option =~ /^Placeholder/; # No help shown for Placeholders.
        if ($option_types{$option} eq 'argv string') {
            print option_help_line(
                $option,
                'string',
                $option_descriptions{$option}     . "\n" .
                $prompt_fors_descriptions{$option}. "\n" .
                $is_storeds_descriptions{$option} . "\n" .
                $sticky_descriptions{$option}     . "\n" .
                "This is a special option for representing everything \n" .
                "remaining on the command line after the named options are\n" .
                "processed. Do not put -$option on the command line."
            );
        } else {
            print option_help_line(
                "-$option",
                $option_types{$option},
                $option_descriptions{$option}     . "\n" .
                $prompt_fors_descriptions{$option}. "\n" .
                $is_storeds_descriptions{$option} . "\n" .
                $sticky_descriptions{$option}     . "\n" .
                $switch_descriptions{$option}
            );
        }
    }
    print <<"    END_OF_SCRIPT_HELP2";
    -help                             bool    Causes this info to be printed, followed by exit.
                                              This can only be entered on the command line.
    -version                          bool    Causes version info to be printed, followed by exit.
                                              This can only be entered on the command line.
    -batch                            bool    Inhibits prompts for unentered options and args.
                                              Also causes option and arg defaults
                                              not to be stored.
                                              Use -batch to pipe input in from another command.
                                              Use -nobatch to force interactive operation.
                                              Forced false if -ask_all is true.
                                              This can only be entered on the command line.
    -debug                            bool    Causes debug info to be printed.
                                              This can only be entered on the command line.
    -noXXX                            bool    The opposite of bool option -XXX.
                                              E.g., -nobatch forces storing defaults and prompting.
    The option processing is POSIX-compliant, so options may be abbreviated
    (e.g -bat for -batch), may be preceded by - or --, may be in any order, and
    are case-insensitive.
    Values for non-boolean options are to follow the option and be separated from it by
    whitespace or an equals sign.  Do not try -batch=true or -batch=false.  Use -batch or -nobatch.
    Piped-in input can be handled by ending command with ' -batch -- -'
    Specifying -batch guarantees there is no prompting for unspecified options
    as long as -ask_all is not specified.  Do not use -ask_all or -nobatch in a pipe.
    Default values are what you get when you run with -batch or, in the interactive mode, you
    just press enter when asked to enter a value.  If you ever need to override a non-blank
    string with a blank one, you will need to type $null_str into the program
    or "" on the command line.
    END_OF_SCRIPT_HELP2
    ###################
    $ask_all = 0; # needed so print_default() calls work right.
    $batch   = 1; # needed so print_default() calls work right.
    print "    Current $pgm defaults for $user in $cwd:\n\n";
    foreach $option (@options) {
        if (0) {
        } elsif ($option eq 'ask_all') {
            print_default2('ask_all', \$ask_all_default, \&get_ask_all_default, \$ask_all);
        } elsif ($option eq 'defaults_file') {
            print_default2('defaults_file', \$defaults_file_default, \&get_defaults_file_default, \$defaults_file);
        } elsif ($option eq 'Commentizer1') {
            print_default2('Commentizer1', \$Commentizer1_default, \&get_Commentizer1_default, \$Commentizer1);
        } elsif ($option eq 'PlaceholderB2') {
            print_default2('PlaceholderB2', \$PlaceholderB2_default, \&get_PlaceholderB2_default, \$PlaceholderB2);
        } elsif ($option eq 'PlaceholderB3') {
            print_default2('PlaceholderB3', \$PlaceholderB3_default, \&get_PlaceholderB3_default, \$PlaceholderB3);
        } elsif ($option eq 'Files') {
            print_default2('Files', \$Files_default, \&get_Files_default, \$Files);
        } elsif ($option eq 'Extns') {
            print_default2('Extns', \$Extns_default, \&get_Extns_default, \$Extns);
        } elsif ($option eq 'BackupDir') {
            print_default2('BackupDir', \$BackupDir_default, \&get_BackupDir_default, \$BackupDir);
        } elsif ($option eq 'StartDir') {
            print_default2('StartDir', \$StartDir_default, \&get_StartDir_default, \$StartDir);
        } elsif ($option eq 'SkipDirPtns') {
            print_default2('SkipDirPtns', \$SkipDirPtns_default, \&get_SkipDirPtns_default, \$SkipDirPtns);
        } elsif ($option eq 'DoFile') {
            print_default2('DoFile', \$DoFile_default, \&get_DoFile_default, \$DoFile);
        } elsif ($option eq 'MaxDepth') {
            print_default2('MaxDepth', \$MaxDepth_default, \&get_MaxDepth_default, \$MaxDepth);
        } elsif ($option eq 'List') {
            print_default2('List', \$List_default, \&get_List_default, \$List);
        } elsif ($option eq 'PlaceholderI4') {
            print_default2('PlaceholderI4', \$PlaceholderI4_default, \&get_PlaceholderI4_default, \$PlaceholderI4);
        } elsif ($option eq 'Commentizer2') {
            print_default2('Commentizer2', \$Commentizer2_default, \&get_Commentizer2_default, \$Commentizer2);
        } elsif ($option eq 'DoDirPtns') {
            print_default2('DoDirPtns', \$DoDirPtns_default, \&get_DoDirPtns_default, \$DoDirPtns);
        } elsif ($option eq 'PlaceholderB1') {
            print_default2('PlaceholderB1', \$PlaceholderB1_default, \&get_PlaceholderB1_default, \$PlaceholderB1);
        } elsif ($option eq 'KeepResult') {
            print_default2('KeepResult', \$KeepResult_default, \&get_KeepResult_default, \$KeepResult);
        } elsif ($option eq 'Decommentize') {
            print_default2('Decommentize', \$Decommentize_default, \&get_Decommentize_default, \$Decommentize);
        } elsif ($option eq 'PlaceholderB4') {
            print_default2('PlaceholderB4', \$PlaceholderB4_default, \&get_PlaceholderB4_default, \$PlaceholderB4);
        } elsif ($option eq 'log_file') {
            print_default2('log_file', \$log_file_default, \&get_log_file_default, \$log_file);
        }
    }
    print "\n    Default file(s) used:\n";
    if (@file_mgr::loaded_default_files) {
        foreach (0 .. $#file_mgr::loaded_default_files) {
            printf "    -defaults_file[%2d]                    => %s\n", $_, $file_mgr::loaded_default_files[$_];
        }
    } else {
        print "    -defaults_file[0]                     => <null>\n";
    }
    print "\nNOTE:  To run interactively, you must enter -nobatch or -ask_all on the command line.\n" if $batch_default;
    if (!$options_valid) {
        print "\nDE: Your command line contained an invalid option.  See above for valid options.\a\n" ;
    }
    print "\n";
    quit();
}
if ($version) {
    print "$pgm version: $pgm_version\n";
    expire();
}
#######################################################################################
## Section: get_*_default
## The following subroutines are for computing defaults and are called in the order established by @options:
sub get_ask_all_default {
    if (!defined($ask_all_default) || !$is_storeds{ask_all}) {
        $ask_all_default = "no"; # Initial default, or the only default if $is_storeds{ask_all} = 0
    }
}
sub get_defaults_file_default {
    if (!defined($defaults_file_default) || !$is_storeds{defaults_file}) {
        $defaults_file_default = "pwiz/$pgm.$user.defaults"; # Initial default, or the only default if $is_storeds{defaults_file} = 0
    }
}
sub get_Commentizer1_default {
    if (!defined($Commentizer1_default) || !$is_storeds{Commentizer1}) {
        my @Extns = split(' ', $Extns);
        $Commentizer1_default =
            $Extns[0] =~ /^(java|c|cpp|h|hpp|js|cs)$/i          ?   '//.'   :
            $Extns[0] =~ /^(pl|pm|.?.?sh|ps1|properties|nsi)$/i ?   '#.'    :
            $Extns[0] =~ /^vbs$/i                               ?   "'."    :
            $Extns[0] =~ /^f\d\d$/i                             ?   '!.'    : # fortran
            $Extns[0] =~ /^bat$/i                               ?   ':.'    :
            $Extns[0] =~ /^(asm|iss)$/i                         ?   ';.'    : # assembly or Inno Setup
            $null_str;
    }
}
sub get_Commentizer2_default {
    if (!defined($Commentizer2_default) || !$is_storeds{Commentizer2}) {
        $Commentizer2_default = $Commentizer1_default;
        $Commentizer2_default =~ s/.$/|/; # replace last char by |
    }
}
sub get_PlaceholderB2_default {
    if (!defined($PlaceholderB2_default) || !$is_storeds{PlaceholderB2}) {
        $PlaceholderB2_default = 'false'; # Initial default, or the only default if $is_storeds{PlaceholderB2} = 0
    }
}
sub get_PlaceholderB3_default {
    if (!defined($PlaceholderB3_default) || !$is_storeds{PlaceholderB3}) {
        $PlaceholderB3_default = "false"; # Initial default, or the only default if $is_storeds{PlaceholderB3} = 0
    }
}
sub get_Files_default {
    if (!defined($Files_default) || !$is_storeds{Files}) {
        $Files_default = ''; # Initial default, or the only default if $is_storeds{Files} = 0
    }
}
sub get_Extns_default {
    if (!defined($Extns_default) || !$is_storeds{Extns}) {
        $Extns_default = 'pl pm'; # Initial default, or the only default if $is_storeds{Extns} = 0
    }
}
sub get_BackupDir_default {
    if (!defined($BackupDir_default) || !$is_storeds{BackupDir}) {
        $BackupDir_default = "$home$path_slash" . base($pgm);
    }
}
sub get_StartDir_default {
    if (!defined($StartDir_default) || !$is_storeds{StartDir}) {
        $StartDir_default = ''; # Initial default, or the only default if $is_storeds{StartDir} = 0
    }
}
sub get_SkipDirPtns_default {
    if (!defined($SkipDirPtns_default) || !$is_storeds{SkipDirPtns}) {
        $SkipDirPtns_default = 'tmp temp old *.old build obj dist bak _history Regression Win32 Debug'; # Initial default, or the only default if $is_storeds{SkipDirPtns} = 0
    }
}
sub get_DoFile_default {
    if (!defined($DoFile_default) || !$is_storeds{DoFile}) {
        $DoFile_default = ''; # Initial default, or the only default if $is_storeds{DoFile} = 0
    }
}
sub get_MaxDepth_default {
    if (!defined($MaxDepth_default) || !$is_storeds{MaxDepth}) {
        $MaxDepth_default = 10; # Initial default, or the only default if $is_storeds{MaxDepth} = 0
    }
}
sub get_List_default {
    if (!defined($List_default) || !$is_storeds{List}) {
        $List_default = ''; # Initial default, or the only default if $is_storeds{List} = 0
    }
}
sub get_PlaceholderI4_default {
    if (!defined($PlaceholderI4_default) || !$is_storeds{PlaceholderI4}) {
        $PlaceholderI4_default = 0; # Initial default, or the only default if $is_storeds{PlaceholderI4} = 0
    }
}
sub get_DoDirPtns_default {
    if (!defined($DoDirPtns_default) || !$is_storeds{DoDirPtns}) {
        $DoDirPtns_default = '*'; # Initial default, or the only default if $is_storeds{DoDirPtns} = 0
    }
}
sub get_PlaceholderB1_default {
    if (!defined($PlaceholderB1_default) || !$is_storeds{PlaceholderB1}) {
        $PlaceholderB1_default = 'false'; # Initial default, or the only default if $is_storeds{PlaceholderB1} = 0
    }
}
sub get_KeepResult_default {
    if (!defined($KeepResult_default) || !$is_storeds{KeepResult}) {
        $KeepResult_default = 'true'; # Initial default, or the only default if $is_storeds{KeepResult} = 0
    }
}
sub get_Decommentize_default {
    if (!defined($Decommentize_default) || !$is_storeds{Decommentize}) {
        $Decommentize_default = 'false'; # Initial default, or the only default if $is_storeds{Decommentize} = 0
    }
}
sub get_PlaceholderB4_default {
    if (!defined($PlaceholderB4_default) || !$is_storeds{PlaceholderB4}) {
        $PlaceholderB4_default = 'false'; # Initial default, or the only default if $is_storeds{PlaceholderB4} = 0
    }
}
sub get_log_file_default {
    if (!defined($log_file_default) || !$is_storeds{log_file}) {
        $log_file_default = "$BackupDir/logs/$pgm.log";
    }
}

#######################################################################################
## Section: get_*
## The following subroutines are for getting the command line variables and are called in the order established by @options:
sub get_ask_all {
    while (1) {
        get_option_val(
            'ask_all',
            "\n(true enables prompting for minor options)",
            \$ask_all,
            \$ask_all_default,
            \&get_ask_all_default,
            $get_input_refs{ask_all}
        );
        # If the validation effected by $regexps{ask_all} needs to be supplemented,
        # add further validation code here by replacing 'if (0)' with your own test and
        # complete the explanation in the print statement:
        if (0) {
            print(qq(ask_all = "$ask_all" is invalid because ...\n));
            undef $ask_all;
            $batch = ''; # prevents infinite loop
            next;
        }
        last;
    }
}
sub get_defaults_file {
    while (1) {
        get_option_val(
            'defaults_file',
            " (name of defaults file)",
            \$defaults_file,
            \$defaults_file_default,
            \&get_defaults_file_default,
            $get_input_refs{defaults_file}
        );
        # If the validation effected by $regexps{defaults_file} needs to be supplemented,
        # add further validation code here by replacing 'if (0)' with your own test and
        # complete the explanation in the print statement:
        if (0) {
            print(qq(defaults_file = "$defaults_file" is invalid because ...\n));
            undef $defaults_file;
            $batch = ''; # prevents infinite loop
            next;
        }
        last;
    }
}
sub get_Commentizer1 {
    while (1) {
        get_option_val(
            'Commentizer1',
            "\n(String used to commentize the directives)",
            \$Commentizer1,
            \$Commentizer1_default,
            \&get_Commentizer1_default,
            $get_input_refs{Commentizer1}
        );
        # If the validation effected by $regexps{Commentizer1} needs to be supplemented,
        # add further validation code here by replacing 'if (0)' with your own test and
        # complete the explanation in the print statement:
        if (0) {
            print(qq(Commentizer1 = "$Commentizer1" is invalid because ...\n));
            undef $Commentizer1;
            $batch = ''; # prevents infinite loop
            next;
        }
        last;
    }
    if ($Commentizer1 =~ /^(.*)[|]$/) {
        $Commentizer2_default = "$1:"; # Initial default, or the only default if $is_storeds{Commentizer2} = 0
    } else {
        $Commentizer2_default = $Commentizer1;
        $Commentizer2_default =~ s/.$/|/;
    }
}
sub get_Commentizer2 {
    while (1) {
        get_option_val(
            'Commentizer2',
            "\n(String used to commentize the inactive lines.  Must differ from \$Commentizer1 ($Commentizer1))",
            \$Commentizer2,
            \$Commentizer2_default,
            \&get_Commentizer2_default,
            $get_input_refs{Commentizer2}
        );
        # If the validation effected by $regexps{Commentizer2} needs to be supplemented,
        # add further validation code here by replacing 'if (0)' with your own test and
        # complete the explanation in the print statement:
        if ($Commentizer1 eq $Commentizer2) {
            print(qq(Commentizer2 = "$Commentizer2" is invalid because it must differ from \$Commentizer1 ($Commentizer1)\n));
            undef $Commentizer2;
            $batch = ''; # prevents infinite loop
            next;
        }
        last;
    }
}
sub get_PlaceholderB2 {
    while (1) {
        get_option_val(
            'PlaceholderB2',
            "\n(Description TBD)",
            \$PlaceholderB2,
            \$PlaceholderB2_default,
            \&get_PlaceholderB2_default,
            $get_input_refs{PlaceholderB2}
        );
        # If the validation effected by $regexps{PlaceholderB2} needs to be supplemented,
        # add further validation code here by replacing 'if (0)' with your own test and
        # complete the explanation in the print statement:
        if (0) {
            print(qq(PlaceholderB2 = "$PlaceholderB2" is invalid because ...\n));
            undef $PlaceholderB2;
            $batch = ''; # prevents infinite loop
            next;
        }
        last;
    }
}
sub get_PlaceholderB3 {
    while (1) {
        get_option_val(
            'PlaceholderB3',
            "\n(Description TBD)",
            \$PlaceholderB3,
            \$PlaceholderB3_default,
            \&get_PlaceholderB3_default,
            $get_input_refs{PlaceholderB3}
        );
        # If the validation effected by $regexps{PlaceholderB3} needs to be supplemented,
        # add further validation code here by replacing 'if (0)' with your own test and
        # complete the explanation in the print statement:
        if (0) {
            print(qq(PlaceholderB3 = "$PlaceholderB3" is invalid because ...\n));
            undef $PlaceholderB3;
            $batch = ''; # prevents infinite loop
            next;
        }
        last;
    }
}
sub get_Files {
    while (1) {
        get_option_val(
            'Files',
            "\n(List of files to preprocess.  May contain wildcard specs.)",
            \$Files,
            \$Files_default,
            \&get_Files_default,
            $get_input_refs{Files}
        );
        # If the validation effected by $regexps{Files} needs to be supplemented,
        # add further validation code here by replacing 'if (0)' with your own test and
        # complete the explanation in the print statement:
        if (0) {
            print(qq(Files = "$Files" is invalid because ...\n));
            undef $Files;
            $batch = ''; # prevents infinite loop
            next;
        }
        last;
    }
}
sub get_Extns {
    while (1) {
        get_option_val(
            'Extns',
            " (Space-separated list of programming language extensions)",
            \$Extns,
            \$Extns_default,
            \&get_Extns_default,
            $get_input_refs{Extns}
        );
        # If the validation effected by $regexps{Extns} needs to be supplemented,
        # add further validation code here by replacing 'if (0)' with your own test and
        # complete the explanation in the print statement:
        if (0) {
            print(qq(Extns = "$Extns" is invalid because ...\n));
            undef $Extns;
            $batch = ''; # prevents infinite loop
            next;
        }
        last;
    }
}
sub get_BackupDir {
    while (1) {
        get_option_val(
            'BackupDir',
            " (directory where backups will be stored)",
            \$BackupDir,
            \$BackupDir_default,
            \&get_BackupDir_default,
            $get_input_refs{BackupDir}
        );
        # If the validation effected by $regexps{BackupDir} needs to be supplemented,
        # add further validation code here by replacing 'if (0)' with your own test and
        # complete the explanation in the print statement:
        if (0) {
            print(qq(BackupDir = "$BackupDir" is invalid because ...\n));
            undef $BackupDir;
            $batch = ''; # prevents infinite loop
            next;
        }
        last;
    }
    $BackupDir = NormalizePath($BackupDir);
}
sub get_StartDir {
    while (1) {
        get_option_val(
            'StartDir',
            "\n(A starting directory from which to search for files to preprocess.  Run $pgm -help for more info.)",
            \$StartDir,
            \$StartDir_default,
            \&get_StartDir_default,
            $get_input_refs{StartDir}
        );
        # If the validation effected by $regexps{StartDir} needs to be supplemented,
        # add further validation code here by replacing 'if (0)' with your own test and
        # complete the explanation in the print statement:
        if (0) {
            print(qq(StartDir = "$StartDir" is invalid because ...\n));
            undef $StartDir;
            $batch = ''; # prevents infinite loop
            next;
        }
        last;
    }
    $Files = '' if $StartDir; # Use only 1 method to specify files.
}
sub get_SkipDirPtns {
    if (!$StartDir) {$SkipDirPtns = ''; return;}
    while (1) {
        get_option_val(
            'SkipDirPtns',
            " (A space-delimited list of directories to skip.  Wildcards allowed.  Run $pgm -help for more info.)",
            \$SkipDirPtns,
            \$SkipDirPtns_default,
            \&get_SkipDirPtns_default,
            $get_input_refs{SkipDirPtns}
        );
        # If the validation effected by $regexps{SkipDirPtns} needs to be supplemented,
        # add further validation code here by replacing 'if (0)' with your own test and
        # complete the explanation in the print statement:
        if (0) {
            print(qq(SkipDirPtns = "$SkipDirPtns" is invalid because ...\n));
            undef $SkipDirPtns;
            $batch = ''; # prevents infinite loop
            next;
        }
        last;
    }
}
sub get_DoFile {
    while (1) {
        get_option_val(
            'DoFile',
            "\n(Name of a file that will be executed by a Perl do statement just prior \n" .
            "to preprocessing all the files found in \$StartDir or in \$Files)",
            \$DoFile,
            \$DoFile_default,
            \&get_DoFile_default,
            $get_input_refs{DoFile}
        );
        # If the validation effected by $regexps{DoFile} needs to be supplemented,
        # add further validation code here by replacing 'if (0)' with your own test and
        # complete the explanation in the print statement:
        if (0) {
            print(qq(DoFile = "$DoFile" is invalid because ...\n));
            undef $DoFile;
            $batch = ''; # prevents infinite loop
            next;
        }
        last;
    }
}
sub get_MaxDepth {
    if (!$StartDir) {$MaxDepth = ''; return;}
    while (1) {
        get_option_val(
            'MaxDepth',
            " (max number of directory levels to search in $StartDir)",
            \$MaxDepth,
            \$MaxDepth_default,
            \&get_MaxDepth_default,
            $get_input_refs{MaxDepth}
        );
        # If the validation effected by $regexps{MaxDepth} needs to be supplemented,
        # add further validation code here by replacing 'if (0)' with your own test and
        # complete the explanation in the print statement:
        if (0) {
            print(qq(MaxDepth = "$MaxDepth" is invalid because ...\n));
            undef $MaxDepth;
            $batch = ''; # prevents infinite loop
            next;
        }
        last;
    }
}
sub get_List {
    while (1) {
        get_option_val(
            'List',
            " Name of a file that contains specs for the files to be processed.",
            \$List,
            \$List_default,
            \&get_List_default,
            $get_input_refs{List}
        );
        # If the validation effected by $regexps{List} needs to be supplemented,
        # add further validation code here by replacing 'if (0)' with your own test and
        # complete the explanation in the print statement:
        if (0) {
            print(qq(List = "$List" is invalid because ...\n));
            undef $List;
            $batch = ''; # prevents infinite loop
            next;
        }
        last;
    }
    if ($List) {
        # If List is specified, then certain other options need not be specified:
        $StartDir = $DoDirPtns = $SkipDirPtns = $MaxDepth = $Files = '';
    }
}
sub get_PlaceholderI4 {
    while (1) {
        get_option_val(
            'PlaceholderI4',
            " (TBD - description for get_opton_val())",
            \$PlaceholderI4,
            \$PlaceholderI4_default,
            \&get_PlaceholderI4_default,
            $get_input_refs{PlaceholderI4}
        );
        # If the validation effected by $regexps{PlaceholderI4} needs to be supplemented,
        # add further validation code here by replacing 'if (0)' with your own test and
        # complete the explanation in the print statement:
        if (0) {
            print(qq(PlaceholderI4 = "$PlaceholderI4" is invalid because ...\n));
            undef $PlaceholderI4;
            $batch = ''; # prevents infinite loop
            next;
        }
        last;
    }
}
sub get_DoDirPtns {
    if (!$StartDir) {$DoDirPtns = ''; return;}
    while (1) {
        get_option_val(
            'DoDirPtns',
            "\nThese are the directories in \$StartDir to consider.  A null string or * means consider all dirs.",
            \$DoDirPtns,
            \$DoDirPtns_default,
            \&get_DoDirPtns_default,
            $get_input_refs{DoDirPtns}
        );
        # If the validation effected by $regexps{DoDirPtns} needs to be supplemented,
        # add further validation code here by replacing 'if (0)' with your own test and
        # complete the explanation in the print statement:
        if (0) {
            print(qq(DoDirPtns = "$DoDirPtns" is invalid because ...\n));
            undef $DoDirPtns;
            $batch = ''; # prevents infinite loop
            next;
        }
        last;
    }
}
sub get_PlaceholderB1 {
    while (1) {
        get_option_val(
            'PlaceholderB1',
            " Description TBD",
            \$PlaceholderB1,
            \$PlaceholderB1_default,
            \&get_PlaceholderB1_default,
            $get_input_refs{PlaceholderB1}
        );
        # If the validation effected by $regexps{PlaceholderB1} needs to be supplemented,
        # add further validation code here by replacing 'if (0)' with your own test and
        # complete the explanation in the print statement:
        if (0) {
            print(qq(PlaceholderB1 = "$PlaceholderB1" is invalid because ...\n));
            undef $PlaceholderB1;
            $batch = ''; # prevents infinite loop
            next;
        }
        last;
    }
}
sub get_KeepResult {
    while (1) {
        get_option_val(
            'KeepResult',
            " - false is for testing only.  Generally, this should be true.",
            \$KeepResult,
            \$KeepResult_default,
            \&get_KeepResult_default,
            $get_input_refs{KeepResult}
        );
        # If the validation effected by $regexps{KeepResult} needs to be supplemented,
        # add further validation code here by replacing 'if (0)' with your own test and
        # complete the explanation in the print statement:
        if (0) {
            print(qq(KeepResult = "$KeepResult" is invalid because ...\n));
            undef $KeepResult;
            $batch = ''; # prevents infinite loop
            next;
        }
        last;
    }
}
sub get_Decommentize {
    while (1) {
        get_option_val(
            'Decommentize',
            " (true means to remove all autogenerated commentizers)",
            \$Decommentize,
            \$Decommentize_default,
            \&get_Decommentize_default,
            $get_input_refs{Decommentize}
        );
        # If the validation effected by $regexps{Decommentize} needs to be supplemented,
        # add further validation code here by replacing 'if (0)' with your own test and
        # complete the explanation in the print statement:
        if (0) {
            print(qq(Decommentize = "$Decommentize" is invalid because ...\n));
            undef $Decommentize;
            $batch = ''; # prevents infinite loop
            next;
        }
        last;
    }
}
sub get_PlaceholderB4 {
    while (1) {
        get_option_val(
            'PlaceholderB4',
            " (Description TBD)",
            \$PlaceholderB4,
            \$PlaceholderB4_default,
            \&get_PlaceholderB4_default,
            $get_input_refs{PlaceholderB4}
        );
        # If the validation effected by $regexps{PlaceholderB4} needs to be supplemented,
        # add further validation code here by replacing 'if (0)' with your own test and
        # complete the explanation in the print statement:
        if (0) {
            print(qq(PlaceholderB4 = "$PlaceholderB4" is invalid because ...\n));
            undef $PlaceholderB4;
            $batch = ''; # prevents infinite loop
            next;
        }
        last;
    }
}
sub get_log_file {
    while (1) {
        get_option_val(
            'log_file',
            " (name of log file)",
            \$log_file,
            \$log_file_default,
            \&get_log_file_default,
            $get_input_refs{log_file}
        );
        # If the validation effected by $regexps{log_file} needs to be supplemented,
        # add further validation code here by replacing 'if (0)' with your own test and
        # complete the explanation in the print statement:
        if (0) {
            print(qq(log_file = "$log_file" is invalid because ...\n));
            undef $log_file;
            $batch = ''; # prevents infinite loop
            next;
        }
        last;
    }
    print("VI: log_file = $log_file\n") if $debug;
}
#######################################################################################
## Section: Call each get_<option> in @options order
foreach $option (@options) { # so to change the options processing order, merely rearrange @options as explained above.
    if (0) {}
    elsif ($option eq 'ask_all'                       ) {&get_ask_all                         ;}
    elsif ($option eq 'defaults_file'                 ) {&get_defaults_file                   ;}
    elsif ($option eq 'Commentizer1'                  ) {&get_Commentizer1                    ;}
    elsif ($option eq 'PlaceholderB2'                 ) {&get_PlaceholderB2                   ;}
    elsif ($option eq 'PlaceholderB3'                 ) {&get_PlaceholderB3                   ;}
    elsif ($option eq 'Files'                         ) {&get_Files                           ;}
    elsif ($option eq 'Extns'                         ) {&get_Extns                           ;}
    elsif ($option eq 'BackupDir'                     ) {&get_BackupDir                       ;}
    elsif ($option eq 'StartDir'                      ) {&get_StartDir                        ;}
    elsif ($option eq 'SkipDirPtns'                   ) {&get_SkipDirPtns                     ;}
    elsif ($option eq 'DoFile'                        ) {&get_DoFile                          ;}
    elsif ($option eq 'MaxDepth'                      ) {&get_MaxDepth                        ;}
    elsif ($option eq 'List'                          ) {&get_List                            ;}
    elsif ($option eq 'PlaceholderI4'                 ) {&get_PlaceholderI4                   ;}
    elsif ($option eq 'Commentizer2'                  ) {&get_Commentizer2                    ;}
    elsif ($option eq 'DoDirPtns'                     ) {&get_DoDirPtns                       ;}
    elsif ($option eq 'PlaceholderB1'                 ) {&get_PlaceholderB1                   ;}
    elsif ($option eq 'KeepResult'                    ) {&get_KeepResult                      ;}
    elsif ($option eq 'Decommentize'                  ) {&get_Decommentize                    ;}
    elsif ($option eq 'PlaceholderB4'                 ) {&get_PlaceholderB4                   ;}
    elsif ($option eq 'log_file'                      ) {&get_log_file                        ;}
} ## end loop over @options
########################################################################################
## Section: Allow user to re-enter params if any were entered
if ($gnrl_utils::get_stdin_ct) {
    $temp = get_stdin("What next?", 'Continue', MkMenu('Continue', 'Correct an entry'));
    StartOver() if $temp =~ /Correct/;
}
########################################################################################
## Section: log actual options used in run
if ($log_file) {
    $log_file = NormalizePath($log_file);
    my $log_size_trigger = 0; ## TBD: change value to alter appending.
    CreateLogFile($log_size_trigger); # Creates or open log_file and makes a few entries
    foreach $option (@options) {
        log_option('ask_all'                       , $ask_all                        ) if $option eq 'ask_all'                      ;
        log_option('defaults_file'                 , $defaults_file                  ) if $option eq 'defaults_file'                ;
        log_option('Commentizer1'                  , $Commentizer1                   ) if $option eq 'Commentizer1'                 ;
        log_option('PlaceholderB2'                 , $PlaceholderB2                  ) if $option eq 'PlaceholderB2'                ;
        log_option('PlaceholderB3'                 , $PlaceholderB3                  ) if $option eq 'PlaceholderB3'                ;
        log_option('Files'                         , $Files                          ) if $option eq 'Files'                        ;
        log_option('Extns'                         , $Extns                          ) if $option eq 'Extns'                        ;
        log_option('BackupDir'                     , $BackupDir                      ) if $option eq 'BackupDir'                    ;
        log_option('StartDir'                      , $StartDir                       ) if $option eq 'StartDir'                     ;
        log_option('SkipDirPtns'                   , $SkipDirPtns                    ) if $option eq 'SkipDirPtns'                  ;
        log_option('DoFile'                        , $DoFile                         ) if $option eq 'DoFile'                       ;
        log_option('MaxDepth'                      , $MaxDepth                       ) if $option eq 'MaxDepth'                     ;
        log_option('List'                          , $List                           ) if $option eq 'List'                         ;
        log_option('PlaceholderI4'                 , $PlaceholderI4                  ) if $option eq 'PlaceholderI4'                ;
        log_option('Commentizer2'                  , $Commentizer2                   ) if $option eq 'Commentizer2'                 ;
        log_option('DoDirPtns'                     , $DoDirPtns                      ) if $option eq 'DoDirPtns'                    ;
        log_option('PlaceholderB1'                 , $PlaceholderB1                  ) if $option eq 'PlaceholderB1'                ;
        log_option('KeepResult'                    , $KeepResult                     ) if $option eq 'KeepResult'                   ;
        log_option('Decommentize'                  , $Decommentize                   ) if $option eq 'Decommentize'                 ;
        log_option('PlaceholderB4'                 , $PlaceholderB4                  ) if $option eq 'PlaceholderB4'                ;
        log_option('log_file'                      , $log_file                       ) if $option eq 'log_file'                     ;
    }
    foreach $temp (0 .. $#file_mgr::loaded_default_files) {
        dif("option -defaults_file[%2d]                = %s", $temp, $file_mgr::loaded_default_files[$temp]);
    }
} else {
    tvi("$pgm is not creating a log_file for this run.");
}
########################################################################################
## Section: User declarations
use vars qw(
    $File
    $BackupFile
    $CommentizerError
    $PgmRoot
    @Lines
    $ChangeCt
    %OldErrLines
    $ErrCt
    %local
    %global
    @DoDirPtns
    @SkipDirPtns
    @DoFilePtns
    @Files
);
#use File::Copy;
use WizFind;
my $EscapedCommentizer1 = quotemeta($Commentizer1);
my $EscapedCommentizer2 = quotemeta($Commentizer2);
my $MaybePtn        = '^(\s*)' . $EscapedCommentizer1 . '(define|show|eval|undef|hide|ifdef|if|ifndef|elif|elsif|elseif|else if|else|endif|end if|end)';
my $definePtn       = '^(\s*)' . $EscapedCommentizer1 . '(define|show) +(.+?)(\s*//.*)?\s*$';
my $undefPtn        = '^(\s*)' . $EscapedCommentizer1 . '(undef|hide) +(.+?)(\s*//.*)?\s*$';
my $evalPtn         = '^(\s*)' . $EscapedCommentizer1 . '(eval) +(.+?)(\s*//.*)?\s*$';
my $ifdefPtn        = '^(\s*)' . $EscapedCommentizer1 . '(ifdef|if) +(.+?)(\s*//.*)?\s*$';
my $ifndefPtn       = '^(\s*)' . $EscapedCommentizer1 . '(ifndef) +(.+?)(\s*//.*)?\s*$'; # ifndef must be in parens here
my $elifPtn         = '^(\s*)' . $EscapedCommentizer1 . '(elif|elsif|elseif|else if) +(.+?)(\s*//.*)?\s*$';
my $elsePtn         = '^(\s*)' . $EscapedCommentizer1 . '(else)(\s*//.*)?\s*$';
my $endifPtn        = '^(\s*)' . $EscapedCommentizer1 . '(endif|end if|end)(\s*//.*)?\s*$';
my $InactivePtn     = '^(\s*)' . $EscapedCommentizer2 . '(.*)$'; # The parens here are needed
my $AbsBackupDir    = File::Spec->rel2abs($BackupDir);
my $FileCt          = 0;
my $ChangedFileCt   = 0;
#############################################
##                                         ##
## Section: START OF MAIN PROCESSING LOGIC ##
##                                         ##
#############################################
if ($List) {
    @Files = superglob('@' . $List);
} elsif ($StartDir) {
    @DoFilePtns = ();
    foreach (split(' ', $Extns)) {
        push (@DoFilePtns, "*.$_");
    }
    tri("$pgm running in $cwd will search for extensions '$Extns' starting at dir $StartDir");
    @DoDirPtns   = split(' ', $DoDirPtns);
    foreach (@DoDirPtns) {$_ = $StartDir . '/' . $_;}
    @SkipDirPtns = split(' ', $SkipDirPtns);
    push (@SkipDirPtns, $BackupDir); # to prevent infinite loop
    WizFind(
        {
            DoDirPtns           => \@DoDirPtns          ,
            SkipDirPtns         => \@SkipDirPtns        ,
            DoFilePtns          => \@DoFilePtns         ,
            LogScans            => 0                    ,
            DoRegularFile       => \&DoFile             , # pushes each found file onto @Files
            DoSoftLinkFile      => \&DoFile             ,
            MaxDepth            => $MaxDepth            ,
        },
        $StartDir
    );
} elsif ($Files) {
    @Files = superglob($Files);
}
if ($DoFile) {
    if (-e $DoFile) {
        tri("Evaluating DoFile $DoFile ...");
        do $DoFile;
        RefLog(\%global, 'RI: global in DoFile: ');
    } else {
        tre("DoFile $DoFile not found");
    }
}
RefLog(\%global, 'RI: global: ');
rif("Number of files to be preprocessed: %d", scalar @Files);
$PgmRoot          = root($pgm);
$CommentizerError = "$Commentizer2 This line will be auto-removed by $PgmRoot on the next successful run";
my $EscapedCommentizerError = quotemeta($CommentizerError);
foreach $File (@Files) {
    $File    = NormalizePath($File);
    my $AbsFile = File::Spec->rel2abs($File);
    if ($File eq '') {
        tre("File name is blank");
        next;
    }
    $BackupFile = $BackupDir . $path_slash . FlattenPath(CutCommonDir($AbsFile, $AbsBackupDir));
    my  @Active             = (1);
    my  @ActiveEver         = (0);
    my  $Level              = 0;
    my  $InactiveLevel      = 0;
    my  $Indent             = '';
    my  @ActiveIndents      = ();
    my  @IfLineNos          = ();
    @Lines                  = ();
    %OldErrLines            = ();
    %local                  = ();
    $ChangeCt               = 0;
    $ErrCt                  = 0;
    #rif("Processing File: $File w/ %d bytes", -s $File);
    open File;
    while (<File>) {
        if (/$EscapedCommentizerError/) {
            $OldErrLines{$. + 1} = $_; # helps calculation of $ChangeCt
            tri("OldErrLine found at line $.");
            next; # Skip error lines from previous run
        }
        chomp;
        #ri("Line=$_");
        my $OldLine = $_;
        s/$InactivePtn/$1$2/ if ! /$MaybePtn/; # remove $Commentizer2 from ordinary code lines
        #RefTee(\@IfLineNos, "VI: IfLineNos @ $.: ");
        if ($IfLineNos[$Level] && /$MaybePtn/ && ! /^$ActiveIndents[$Level]/) {
            HandleError("Endif is missing for the if... at line $IfLineNos[$Level]");
            $IfLineNos[$Level] = 0;
            $Level-- if $Level;
        }
        if ($Decommentize) {
            # nothing left to do - all Commentizer2s that need to be removed have been removed.
        } elsif ($Active[$Level]) {
            #tri("\$ActiveEver[$Level]: $ActiveEver[$Level]");
            if (/$definePtn/) {
                HandleDefine($3);
            } elsif (/$undefPtn/) {
                HandleUndef($3);
            } elsif (/$evalPtn/) {
                Eval($3);
            } elsif (/$ifdefPtn/ || /$ifndefPtn/) {
                $Level++;
                $ActiveIndents[$Level]  = $1;
                $IfLineNos[$Level]      = $.;
                if (/$ifdefPtn/ ? Eval($3) : ! Eval($3)) {
                    $Active[$Level]         = 1;
                    $ActiveEver[$Level]     = 1;
                } else {
                    $Active[$Level]         = 0;
                    $InactiveLevel          = $Level;
                    $ActiveEver[$Level]     = 0;
                    $Indent                 = $1;
                }
            } elsif (/$elifPtn/) {
                if ($ActiveEver[$Level]) {
                    $Indent                 = $1;
                    $Active[$Level]         = 0;
                    $InactiveLevel          = $Level;
                } else {
                    if (Eval($3)) {
                        $Active[$Level]         = 1;
                        $ActiveEver[$Level]     = 1;
                    } else {
                        $Active[$Level]         = 0;
                        $Indent                 = $1;
                        $InactiveLevel          = $Level;
                    }
                }
            } elsif (/$elsePtn/) {
                if ($ActiveEver[$Level]) {
                    $Active[$Level]         = 0;
                    $Indent                 = $1;
                    $InactiveLevel          = $Level;
                } else {
                    $Active[$Level]         = 1;
                    $ActiveEver[$Level]     = 1;
                }
            } elsif (/$endifPtn/) {
                $IfLineNos[$Level] = 0;
                #RefTee(\@IfLineNos, "VI: IfLineNos @ $. after   active endif: ");
                $Level--;
            } elsif (/$MaybePtn/) {
                HandleError("Badly formed directive in the next line");
            }
        } else {
            my $Commentize = 1; # tentatively
            if (/$definePtn/ || /$undefPtn/ || /$evalPtn/) {
                # nothing to do
            } elsif (/$ifdefPtn/ || /$ifndefPtn/) {
                $Level++;
                $ActiveIndents[$Level]  = $1;
                $IfLineNos[$Level]      = $.;
                $Active[$Level]         = 0;
                $ActiveEver[$Level]     = 0;
                $Commentize = $InactiveLevel < $Level;
            } elsif (/$elifPtn/) {
                if ($ActiveEver[$Level]) {
                    $Indent         = $1;
                } elsif ($Active[$Level - 1]) {
                    if (Eval($3)) {
                        $Active[$Level]     = 1;
                        $ActiveEver[$Level] = 1;
                    } else {
                        $Indent             = $1;
                    }
                }
                $Commentize = $InactiveLevel < $Level;
            } elsif (/$elsePtn/) {
                if ($ActiveEver[$Level]) {
                    $Indent             = $1;
                } elsif ($Active[$Level - 1]) {
                    $Active[$Level]     = 1;
                    $ActiveEver[$Level] = 1;
                }
                $Commentize = $InactiveLevel < $Level;
            } elsif (/$endifPtn/) {
                $IfLineNos[$Level] = 0;
                #RefTee(\@IfLineNos, "VI: IfLineNos @ $. after inactive endif: ");
                $Commentize = $InactiveLevel < $Level;
                $Level--;
            } elsif (/$MaybePtn/) {
                HandleError("Badly formed directive in the next line");
            }
            $_ =~ s/^$Indent/$Indent$Commentizer2/ if $Commentize;
        }
        if ($Level < 0) {
            HandleError("Excessive endifs");
            $Level = 0;
        }
        push (@Lines, "$_\n");
        #tri("\$Active[$Level]: $Active[$Level]  \$ActiveEver[$Level]: $ActiveEver[$Level]  \$ChangeCt: $ChangeCt  \$ErrCt: $ErrCt  after: $_");
        $ChangeCt++ if ($OldLine ne $_);
    } # endloop over lines in File
    if ($Level > 0) {
        # Much of the commentizing may have been done in error, so remove it all
        seek(File, 0, 0);
        @Lines = <File>;
        $.++; # Effective line number of EOF
        HandleError("Missing endif(s) in some preceding line(s).");
    }
    close File; # Do not close file until after final error check since $. would be invalidated.
    #--RefTee(\%local, "VI: Final locals for $File: ");
    #--RefTee(\%OldErrLines, "VI: OldErrLines: ");
    my $OldErrCt = scalar keys %OldErrLines;
    #tri("OldErrCt $OldErrCt  ErrCt $ErrCt");
    $ChangeCt++ if ($OldErrCt != $ErrCt);
    CreateFile();
    tre("$ErrCt errors detected in $File") if $ErrCt;
    $ChangedFileCt++ if $ChangeCt;
    $FileCt++;
}
if ($ChangedFileCt) {
    if ($KeepResult) {
        trif("** $ChangedFileCt of %d files were changed.  Your backups are in $BackupDir  Run time %d secs. **", scalar(@Files), time - $^T);
    } else {
        trif("** $ChangedFileCt of %d files would have been changed if \$KeepResult were true.  Run time %d secs. **", scalar(@Files), time - $^T);
    }
} else {
    trif("None of the %d files checked needed to be changed.  Run time %d secs.", scalar(@Files), time - $^T);
}
quit();
###################################################################################################
sub HandleDefine {
    my $LocalVar = $_[0];
    #tri("Defining: $LocalVar");
    if ($LocalVar =~ /^\w*$/) {
        $local{$LocalVar} = 1;
    } else {
        HandleError("'$LocalVar' invalid in a define directive");
    }
}
###################################################################################################
sub HandleUndef {
    my $LocalVar = $_[0];
    #tri("Undefing: $LocalVar");
    if ($LocalVar =~ /^\w*$/) {
        $local {$LocalVar} = 0;
    } else {
        HandleError("'$LocalVar' invalid in an undef directive");
    }
}
###################################################################################################
sub Eval {
    my $Expr = $_[0];
    my $Result;
    #tri("Evaling: $Expr");
    while ($Expr !~ /[\$'"%]/ && $Expr =~ /(.*?)(\b[a-z]\w*\b)(.*)/i) { # then $Expr contains no strings or Perl variables
        my $Prefix = $1;
        my $Var    = $2;
        my $Suffix = $3;
        #tri("VAR    : $Var");
        if    (defined($local {$Var})) {$Var = $local {$Var};}
        elsif (defined($global{$Var})) {$Var = $global{$Var};}
        elsif (defined($ENV   {$Var})) {$Var = $ENV   {$Var};}
        else                           {$Var = 0            ;}
        $Var = 1 if $Var =~ /[a-z]/i;
        $Expr = $Prefix . $Var . $Suffix;
    }
    #tri("Evaling: $Expr (final complex)");
    $Result = eval "no warnings 'all';$Expr;";
    if ($@) {
        chomp $@;
        $@ =~ s/([\r\n]+)/ /g;
        HandleError("error in eval: $@");
        $Result = 0;
    }
    #tri("Result : $Result");
    return $Result;
}
###################################################################################################
sub HandleError {
    tre("$File:$. $_[0]");
    my $NewErrLine = "**** $_[0] **** $CommentizerError\n";
    push (@Lines, $NewErrLine);
    $ErrCt++;
    $ChangeCt++ if (!defined($OldErrLines{$.}) || $NewErrLine ne $OldErrLines{$.});
}
###################################################################################################
sub CreateFile { # Stuff @Lines into $BackupFile and handle the copying and file timestamp
    #trif("\@Lines has %d lines", scalar @Lines);
    if ($ChangeCt) {
        if ($KeepResult) {
            mkdir_tree(path($BackupFile));
            qarchive($BackupFile);
            rename ($File, $BackupFile);
            safely_create(*File); # this aborts if File cannot be created.
            binmode File;
            foreach (@Lines) {print File $_;}
            close File;
            rif("%3d changes: %-60s  Backup: $BackupFile", $ChangeCt, $File);
        } else {
            ri("$ChangeCt changes would be made in $File if \$KeepResult were true");
        }
    } else {
        ri("No  changes: $File");
    }
}
###################################################################################################
sub DoFile {
    my $FullFileName = $_[0]; # string ref
    #tri("Doing $$FullFileName");
    push(@Files, $$FullFileName); # Full name should be used since $cwd is not necessarily $StartDir.
}
###################################################################################################
###################################################################################################
###################################################################################################
###################################################################################################
###################################################################################################
###################################################################################################
__END__
